\chapter{Stand van zaken}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

% Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet er nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

% Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz. naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\TeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin, gebruik je \texttt{$\backslash${}textcite\{\}}.
% Soms wil je de auteur niet expliciet vernoemen, dan gebruik je \texttt{$\backslash${}autocite\{\}}. In de volgende paragraaf een voorbeeld van elk.

% \textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

Programmeerparadigma's omschrijven een manier van programmeren. Dit kan de syntax, algemene stijl of de manier waarop een programma wordt uitgevoerd omvatten*BRON*. Het al dan niet ondersteunen van één of meerdere van deze paradigma's is een manier om de vele programmeertalen op te delen. Eén van de meest simpele paradigma's is imperatief programmeren. Code gebaseerd op dit paradigma voert instructie per instructie uit om zo tot een uiteindelijk resultaat te komen. Dit leidde echter tot zogenaamde \textit{spaghetti code}*BRON*, code die ongestructureerd is en daardoor moeilijk om te onderhouden. Object-Oriented (Object-Geörienteerd) programmeren probeerde hier een eind aan te maken door de code te structureren in objecten. Een poging die succesvol blijkt te zijn want OOP groeide uit tot het meest gebruikte programmeerparadigma*BRON*. 

\section{Object-Oriented programmeren}
\subsection{Achtergrond}
OOP is een manier van programmeren die in simpele zin werkt met objecten die onderling berichten versturen naar elkaar*BRON*. Een object heeft \textit{state} (data in variabelen) en gedrag (methoden). Objecten communiceren met elkaar door methodes aan te roepen van andere objecten. Het aanmaken van objecten gebeurt d.m.v. klassen*BRON*. Klassen definiëren objecten die dezelfde \textit{state} en hetzelfde gedrag hebben en vormen een blauwdruk waarmee deze objecten kunnen aangemaakt worden tijdens de uitvoering van een programma. Een constructor*BRON* maakt het mogelijk om hiervan een object te maken.

\subsection{Concepten}
De concepten of soms ook bekend onder de naam 'pilaren' van OOP laten toe om code zodanig te structureren om het gebruik en onderhoud ervan te vergemakkelijken. Het toepassen van deze concepten wil nog niet zeggen dat de geschreven code goed is, correct gebruik van OOP hangt nog steeds af van het juist toepassen van de verschillende concepten aan de gepaste situaties. De vier bekendste concepten zijn Overerving, Abstractie, Polymorfisme en Encapsulatie*BRON*.

\begin{description}
   \item[Overerving] Ook wel bekend als specialisatie. Klassen kunnen overerven van andere klassen om zo uit te breiden (te specialiseren) op diens \textit{state} en gedrag. Zo kan bv. een klasse Student overerven van een klasse Persoon en uitbreiden op deze klasse met als extra \textit{state} een studentennummer en extra gedrag in de vorm van een methode 'studeren'. 
    Overerving laat hergebruik van klassen toe en kan een ontwikkelaar klassen naar wensen afstellen door deze uit te breiden. 
    \item[Abstractie] Abstracties maken van klassen simplificeren deze door ze te versimpelen d.m.v. het verwijderen van details zoals zodat een gebruiker een simpele weergave krijgt van een object zonder al de specifieke implementaties. Wanneer een object een methode aanroept op een ander wil deze vaak enkel een resultaat, voor het aanroepende object maakt het niet uit welke soort object het ander is, wat het allemaal kan of wat de implementatie van de aangeroepen methode is.
    \item[Polymorfisme] Dit concept stelt objecten in staat om te reageren op eenzelfde boodschap met eigen gedrag. Zo kan een object een methode aanroepen op een object en een resultaat terugkrijgen dat verschillend is als het dezelfde methode zou aanroepen op een ander object. Een algemene basisklasse declareert zo'n methode en andere klassen kunnen of soms moeten deze implementeren bij het uitbreiden van deze klasse. Dit duidt men vaak aan via een \textit{override} sleutelwoord. Een object die een andere object van die basisklasse bevat roept dan de methode aan en de runtime*BRON**UITLEG IN FOOTER?* checkt welke implementatie er van toepassing is door te kijken naar het runtime type van het object, wat het type van één van de afgeleide objecten van de basisklasse zal zijn.
    \item[Encapsulatie] Encapsulatie breidt verder uit op abstractie door het afschermen van details die niet zichtbaar hoeven te zijn. Dit gebeurt a.d.h.v. \textit{access modifiers}*BRON*. In Java zijn dit private, protected, package (default) en public. Een goede regel is om enkel zichtbaar te maken wat echt zichtbaar hoeft te zijn (dit zijn dan vaak methodes) en de onnodige details afschermen.
\end{description}

\subsection{Design Patterns}
Design patterns zijn simpel gesteld kant-en-klare oplossingen voor specifieke problemen. In applicatieontwikkeling is het een best practice om te vermijden om het wiel te heruitvinden, daarom werden design patterns opgesteld om zo een referentie te bieden voor andere ontwikkelaars om een bepaalde probleem op te lossen. Want net zoals het herhalen van code worden ook problemen vaak herhaald. OOP is niet perfect maar door de correcte implementatie van design patterns kan een ontwikkelaar het maximum halen uit de mogelijkheden van OOP zonder zichzelf in de voet te schieten door terug spaghetticode te schrijven zoals het geval is bij imperatief programmeren. Hoewel er talloze design patterns bestaan zullen hier slechts enkele besproken worden die relevant zijn voor het onderzoek.

\begin{description}
  \item [Model-View-Controller] MVC is een pattern dat vooral betrekking heeft tot de opbouw van een applicatie met een user interface. Het koppelt de UI los van de domein logica d.m.v. een controller die zal zorgen voor de communicatie tussen Model (domein) en View. In kleine en simpele applicaties is dit vaak één zogenaamde \textit{domeincontroller} die de juiste objecten zal aanspreken om te voldoen aan de vragen die vanuit de UI komen. 
  \item [Model-View-Viewmodel] Net als MVC is MVVM ook een architecturaal pattern. Hier zorgt het Viewmodel voor de ontkoppeling tussen Model en View door de (vaak afgeschermde) data van een Model bloot te stellen voor de View. Via \textit{data binding} koppelt de View zich dan aan de Viewmodel. Deze binding zorgt voor de synchronisatie van data tussen Viewmodel en View zodat steeds de meeste actuele data wordt getoond aan de gebruiker. 
  % Overige patterns nog toevoegen?
\end{description}

\subsection{SOLID}
SOLID is een acronym dat de 5 principes van OOP (niet te verwarren met de eerder vermelde concepten/pillaren) omschrijft die werden opgesteld door Robert C. Martin \autocite{Buysse2017-2018}.  Het juist volgen van deze principes zorgt ook voor makkelijk onderhoudbare en uitbreidbare code. De principes zijn als volgt:
\begin{description}
  \item [Single responsibility principle] Elke klasse heeft maar één verantwoordelijkheid in een applicatie. Zo wordt het makkelijker om veranderingen aan te brengen in de code zonder neveneffecten. Het vermijd ook het maken van een \textit{god object}*BRON*, een object dat te veel doet en/of te veel weet.
  \item [Open-closed principle] Code moet open zijn voor uitbreidingen maar afgesloten voor wijzigingen. M.a.w. het moet mogelijk zijn om op een klasse, functie, etc. uit te breiden zonder daarvoor de originele code te moeten wijzigen. 
  \item [Liskov substitution principle] Waar men een bepaalde klasse verwacht daar moet een subklasse voor kunnen instaan. Een subklasse kan op een methode van een superklasse uitbreiden maar kan deze niet inperken. Zo moet de input (aantal en type van de parameters) en output (return type) hetzelfde blijven.
  \item [Interface segregation principle] Het correct volgen van dit principe vermijd het maken van te grote interfaces*UITLEG IN FOOTER?* met methodes die dan een onnodige implementatie vereisen wanneer klasse slechts enkele methodes van deze interface nodig hebben.
  \item [Dependency inversion principle] Abstractie staat centraal bij dit principe. Een abstractie ontkoppelt \textit{dependencies} van elkaar en zorgt ervoor dat die enkel afhankelijk zijn van de abstractie, dus niet meer van de details van elkaar.
\end{description}

Correct gebruik van OOP kan leiden tot herbruikbare en makkelijk uitbreidbare code en dit voordeel heeft het laten uitgroeien tot het meest gebruikte programeerparadigma. Klassen zijn vaak afgeleid van objecten in de echte wereld en dit maakt het geheel makkelijk verstaanbaar en leesbaar. Aan OOP zijn er echter ook nadelen verbonden. Zo is er typisch veel code nodig bij een OOP aanpak en is die ook minder performant door de verschillende objecten die bij elkaar methodes aanroepen. Een ander nadeel is dat het zich niet zo goed leent bij parallelle processen doordat data in allerlei objecten verscholen zit en dus de \textit{state} van het programma continu door andere objecten kan veranderd worden. OOP is dus geen \textit{all-round} paradigma en ondanks zijn populariteit de voorbije decennia blijft het toch niet het enigste paradigma waarin ontwikkelaars programmeren. Functioneel programmeren is een paradigma die aan populariteit blijft winnen en die geen last heeft van de nadelen van OOP (maar wel andere nadelen met zich mee kan brengen).

\section{Functioneel programmeren}
\subsection{Achtergrond}
Zoals de naam al doet vermoeden staan functies centraal bij FP. Functies nemen data als input geven daarop een output terug zonder de originele data te veranderen. \textit{Immutability}*BRON* is dan ook zeer belangrijk binnen dit paradigma. Alhoewel functioneel programmeren nog maar redelijk recent aan populariteit wint, is het concept toch al reeds bekend sinds de introductie van Lambdacalculus door Alonzo Church in de jaren 30*BRON*. Lambdacalculus maakt gebruikt van zogenaamde pure functies en vormt de basis voor het functioneel programmeren paradigma. Er bestaan talen specifiek gericht op die paradigma zoals Lisp, Scala, Haskell en Erlang. Ondersteuning voor FP kwam er ook talen voor zoals Java (lambda's en streams) en C\# (LINQ). Het enige wat een programmeertaal moet ondersteunen om aan FP te kunnen doen zijn zogenaamde \textit{higher-order functions} net zoals het geval is bij lambda calculus *BRON*. Hierdoor kan men ook gebruik maken van currying. Deze concepten van FP komen nu aan bod in volgende secties.

\subsection{Lambdacalculus}
Daar dit geen wiskundige paper is zal er niet diep worden ingegaan op de Lambdacalculus maar zal er slechts een korte uitleg volgen om de basis achter FP te illustreren. Op zich is Lambdacalculus eigenlijk een programmeertaal, al is die \textit{low-level}. Lambdacalculus werkt met pure functies, deze krijgen een input en geven een output terug. Deze functies zijn puur omdat ze voor dezelfde input steeds dezelfde output teruggeven. De functies hebben een \textit{black box} structuur, het is dus niet geweten hoe die functies precies werken, enkel hun input en output is gekend. Dit leidt tot al één concept binnen FP; de focus op programmeren \textbf{wat} je wil bereiken en niet \textbf{hoe}. De input en output van functies binnen Lambdacalculus kunnen op hun beurt ook functies zijn, dit zijn dan de zogenaamde \textit{higher order functions}. Variabelen binnen Lambdacalculus zijn constant, ze veranderen dus niet en zijn m.a.w. \textit{immutable}.

\subsection{Functies in Functioneel Programmeren}
De functies binnen FP moeten puur zijn, d.w.z. ze krijgen een input en geven voor één input één en dezelfde output. Deze pure functies hebben dus geen neveneffecten, ze beïnvloeden geen globale variabelen of andere soort van \textit{state}. Het testen van deze functies is dan ook zeer makkelijk aangezien ze bij dezelfde parameters telkens dezelfde output geven, zonder uitzondering.
Verder zijn deze functies ook zogenaamde \textit{higher-order} functies. Ze kunnen andere functies als argument nemen en/of een functie retourneren.
Hiervoor is het vooral nodig dat de programmeertaal waarin een ontwikkelaar werkt \textit{first-class} functies ondersteunt, d.w.z. dat de taal functies behandelt net zoals alle andere types van data m.a.w. ze kunnen naast voorgenoemde toepassingen ook aangemaakt en opgeslagen worden in variabelen.

\subsection{Currying}
Deze techniek is vernoemd naar Haskell Curry (wiens voornaam ook de naam is van de functionele programmeertaal). Het omvat een techniek waarmee men een functie die meerdere parameters heeft opsplitst in een sequentie van functies met telkens één parameter. Zo ontstaan er verschillende deelfuncties die kunnen opgeslagen worden in variabelen. Op die manier is het ook makkelijk om deze functies te hergebruiken in andere delen van de applicatie. Currying werkt ook hand in hand met \textit{dependency injection}*BRON*, wanneer je parameters van elders worden doorgegeven.

\subsection{Immutable}
Nog een centraal concept binnen FP is \textit{immutable} data. D.w.z. data die niet meer ongewijzigd blijft. Dit werkt hand-in-hand met het concept van pure functies, aangezien deze geen neveneffecten hebben en enkel output retourneren gebaseerd op hun input. Werken met \textit{immutable} data is vooral ideaal voor applicaties die gebruik maken van \textit{multithreading} en parallelle processen. Aangezien deze data niet verandert kunnen er zich ook geen problemen voordoen bij het gelijktijdige schrijfoperaties.

\subsection{Map en Reduce}
Binnen FP hebben loops geen plaats, aangezien dit meestal aanleiding geeft tot het muteren van \textit{state}. Naast het gebruik van recursie bestaan er binnen FP de functies \textit{map} en \textit{reduce}, twee functies die gebruikt kunnen worden om te werken met collecties. \textit{Map} verwacht een functie als parameter die op elk element zal uitgevoerd worden. \textit{Reduce} verwacht een functie en een initiële waarde en zal alle via die functie en waarde alle elementen verwerken tot één element. Deze twee functies lopen parallel met de gedachtegang van FP, de ontwikkelaar zal vooral specificeren wat hij wil doen maar niet hoe, de specifieke implementatie van deze functies speelt geen rol binnen de scope van de applicatie die de ontwikkelaar wil bouwen. Deze functies vormen de basis van andere vaak voorkomende functies om met collecties te werken zoals \textit{find}, \textit{filter}, \textit{any} e.a.

Functioneel programmeren wint alsmaar meer aan populariteit en dat is te zien aan de verschillende talen die dit (al dan niet gedeeltelijk) ondersteunen. Eén taal waarbij zowel OOP en FP mogelijk zijn op verschillende gradaties is JavaScript, dé programmeertaal voor webontwikkeling. Dankzij zijn vele frameworks en consistente verbeteringen is het dan ook één van de populairste talen op dit moment.

\section{JavaScript}
\subsection{Achtergrond}
JavaScript is al jaren een veel gebruikte taal voor webontwikkeling. De taal zelf kent een zeer moeizame groei doordat hij vroeger vaak geplaagd werd door allerlei problemen zoals *VOORBEELD*. Waar het vroeger voornamelijk werd gezien als een scripting taal om statische websites iets dynamischer te maken krijgt de taal nu alsmaar meer aandacht door het opkomen van allerlei innovatieve frameworks en de introductie van TypeScript (Microsoft) en Flow (Facebook) waarmee ontwikkelaars aan de slag kunnen met types binnen JavaScript. JavaScript is dan ook altijd al een \textit{weakly-typed} taal geweest maar dankzij deze recente ontwikkelingen begint de taal meer op een programmeertaal te lijken. De naamgelijkheid met Java is immers altijd enkel een manier geweest om van wat naambekendheid te profiteren, de twee talen hebben amper iets met elkaar te maken. Maar dankzij de continue introductie van nieuwe standaarden binnen de taal beginnen ze toch meer op elkaar te lijken.

\subsection{EcmaScript}
EcmaScript is de standaard voor JavaScript die continu nieuwe features toevoegt aan de taal om deze steeds te verbeteren. EcmaScript 5 had een enorme invloed op de taal dankzij de vele verbeteringen die het introduceerde. Zo kwam er klasse syntax inclusief getter en setters die het eenvoudiger maakte om met klassen en overerving te werken, import statements om externe modules in te laden, \textit{let} en \textit{const} om variabelen te declareren die \textit{block scope} hadden i.p.v. \textit{var} die \textit{function scoped} was, de \textit{spread} en \textit{rest} operators en nog veel meer. Toenmalige code werd al snel gedateerd door de introductie van deze features.

\subsection{Klassen}
Klassen werden geïntroduceerd in de EcmaScript 5 standaard waardoor het makkelijker werd om aan OOP te doen zoals ontwikkelaars gewend waren van talen zoals Java en C\#. Deze klassen werken echter niet helemaal zoals ze in die talen werken, dat blijkt aan het grote probleem met \textit{this}. Als \textit{this} voorkomt in een klasse dan verwijst die naar die specifieke klasse maar in JavaScript is dit soms niet geval zoals bv. bij event handling waar\textit{this} dan eerder naar het event verwijst dan naar de klasse. Dit zorgt vaak voor verwarring bij ontwikkelaars die een andere taal gewend zijn, maar ook bij een ervaren JavaScript ontwikkelaar blijft dit een probleem.

\subsection{Node.js}
JavaScript draaide origineel enkel binnen een browser en werd daarom enkel gebruikt voor frontend ontwikkeling. Hier kwam echter verandering in dankzij Node.js. Hiermee werd het ook mogelijk om JavaScript op een server te draaien met als gevolg dat de taal ook kon gebruikt worden voor backend ontwikkeling. Hoewel er veel externe libraries bestaan binnen de taal blijft Node.js één van de meest belangrijke die nog steeds relevant is en blijft gebruikt worden bij de ontwikkeling van nieuwe applicaties. Ook op het vlak van backendtechnologieën in het algemeen blijft het populair naast anderen zoals .NET.

\subsection{React en Angular}
Deze populaire frameworks (opgericht door Facebook enerzijds en door Google anderzijds) zijn gericht op een componenten structuur om zo een applicatie modulair te maken, wat de verantwoordelijkheid van de functionaliteiten van de applicatie gaat verdelen over de verschillende gebruikte componenten. Dit heeft als gevolg dat de applicatie makkelijker testbaar en onderhoudbaar wordt. Doordat de componenten op meerdere verschillende plaatsen kunnen gebruikt worden maakt het de code ook herbruikbaar. React verwezenlijkt dit door het gebruik van JSX, een syntax met een HTML/XML structuur die compileert naar verschillende functieaanroepen en zo de verschillende componenten creëert. Het simplificeert één van de moeilijkste kanten van webontwikkeling: werken met het DOM*BRON, UITLEG?*. De oplossing van React hiervoor is een eigen DOM waar het gebruik van maakt om UI's te renderen. Elk component binnen React krijgt \textit{props} binnen van buitenaf en heeft al dan niet interne \textit{state}. Als één van deze twee veranderen dan rendert de component opnieuw in de applicatie zodat die steeds geüpdatet blijft en niet statisch. Naast React bestaat er ook nog React Native, een taal die het mogelijk maakt om met React mobiele applicaties te schrijven voor zowel Android als iOS.

Angular is vooral populair voor \textit{Single Page Applications}. Zo draait een applicatie op slechts één pagina in de browser maar heeft die toch nog een dynamische UI. Een component in Angular bestaat uit 3 delen: de HTML (weergave), de CSS (opmaak) en het JavaScript (dynamisch) gedeelte. Naast de standaard HTML tags komen er bij Angular extra tags bij, de de zogenaamde \textit{directives} *BRON*. Deze directives breiden standaard HTML tags uit (m.a.w. overerving), dit vormt de basis van de werking van Angular. Het framework maakt vooral gebruik van het Model-View-Viewmodel (MVVM) patroon door data binding. Zo wordt een View (de HTML) verbonden met het Viewmodel (JavaScript) die vaak een Model (data) heeft en die bepaalde eigenschappen van die data zal blootstellen aan de HTML code. D.m.v. data binding blijft de data die wordt weergeven in de HTML pagina gesynchroniseerd. Zo toont een ng-if directive enkel zich enkel als het voldoet aan een conditie. Als men die conditie bind aan een property die wordt blootgesteld in het Viewmodel dan zal deze component zich automatisch tonen of verbergen naargelang de property verandert door een handeling binnen de code.  

\subsection{Object Oriented}
JavaScript is een \textit{multiparadigm} taal, dus het kan zowel gebruikt worden bij een OOP als een FP aanpak*BRON. Als je met objecten werkt binnen JavaScript is dit echter niet hetzelfde zoals je bij andere talen zou verwachten. Hoewel klassen werden geïntroduceerd in de EcmaScript 5 standaard blijft JavaScript een \textit{prototype based} OOP taal*BRON*. Dit betekent dat alle objecten een prototype als property hebben waarbij reeds methodes en \textit{state} horen (dit is overerving). Dit werkt niet hetzelfde als met klassen, aangezien je tijdens \textit{runtime} het prototype van een object kan veranderen zodat deze ander gedrag en \textit{state} kan hebben. Om uit te breiden op een object moet je de gewenste methoden en \textit{state} toevoegen aan hun prototype. Indien een ander object hetzelfde gedrag en \textit{state} wil van een ander object dan kan het prototype van dit object ingesteld worden met een prototype van het ander. Alle objecten hun prototype zijn afgeleid van het Object object, wiens eigen protoptype verwijst naar \textit{null}. Dankzij de introductie van klassen in ES5 komen JavaScript nog maar weinig in aanraking de \textit{prototype-based inheritance} van de taal maar dit is slechts een verkorte syntax, achter de schermen wordt er nog steeds gewerkt met prototype hoewel de code al meer lijkt op klassen die je vindt in bv. een Java applicatie *BRON*. Een object is ook heel verschillend van andere OOP talen en werkt eerder als een key/value verzameling, een associatieve array. Velden binnen dit object worden niet vooraf gedefinieerd en kunnen zo worden toegevoegd tijdens \textit{runtime}. Ze worden uiteraard ook niet getypeerd aangezien JavaScript zwak en dynamisch getypeerd is. Dit verschil in aanpak van OOP blijft een struikelblok voor ontwikkelaars en daarom wordt er meer aangeraden om binnen JavaScript te werken met het FP paradigma. Het Angular framework gaat alleszins nauw samen met OOP doordat de basis al ligt in één van de hoofdconcepten: Overerving. De directives binnen Angular erven over van standaard HTML tags en stellen ontwikkelaars zo in staat om dynamische Single Page Applications te creeëren a.d.h.v. HTML en JavaScript.

\subsection{Functioneel}
Functioneel programmeren is al mogelijk sinds de conceptie van JavaScript, omdat de taal gebaseerd is op \textit{Scheme}*BRON*, een FP taal. Functies binnen JavaScript zijn \textit{first class objects} en de taal ondersteunt daarmee dus ook \textit{higher order} functies*BRON*. Zo beschikt de taal over al het nodige om aan FP te doen maar is het nog steeds niet verplicht om enkel op die manier te werken. Het brengt wel een aantal voordelen met zich mee zoals niet meer afhankelijk zijn van de soms onverwachte resultaten door het gebruik van prototype en \textit{this}. Het maakt de code ook makkelijk herbruikbaar en modulair door hergebruik van functies. Data binnen JavaScript is niet altijd immutable. Zo zijn er nog steeds de declaraties \textit{var} en \textit{let} van welke de waarde mogen veranderen maar ook \textit{const} is niet volledig immutable *HIER NOG MEER UITLEG VAN EN BRON*. Om echt immutable data te gebruiken heeft men binnen JavaScript nood aan een externe library, zoals bv. Immutable.js (ontwikkeld door Facebook).

React leunt ook steeds meer aan tegen deze aanpak, aangezien ze aanraden om zoveel mogelijk functionele componenten te maken en geen componentklassen. Zo past men één van de principes van FP toe: pure functies. Deze functionele componenten zijn enkel afhankelijk van hun props, de input, en niet nog van een interne \textit{state} of andere zaken waardoor er neveneffecten kunnen ontstaan. Immutability is ook belangrijk binnen het React framework omdat het zo makkelijker is voor een component om te weten of die opnieuw moet gerenderd worden als één of meerdere props wijzigen. * TODO: FUNCTIONEEL IN ANGULAR?? *