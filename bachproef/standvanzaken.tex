\chapter{Stand van zaken}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

% Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet er nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

% Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz. naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\TeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin, gebruik je \texttt{$\backslash${}textcite\{\}}.
% Soms wil je de auteur niet expliciet vernoemen, dan gebruik je \texttt{$\backslash${}autocite\{\}}. In de volgende paragraaf een voorbeeld van elk.

% \textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

Programmeerparadigma's omschrijven een manier van programmeren. Dit kan de syntax, algemene stijl of de manier waarop een programma wordt uitgevoerd omvatten \autocite{VanRoy2004}. Het al dan niet ondersteunen van één of meerdere van deze paradigma's is een manier om de vele programmeertalen op te delen. Twee simpele vormen van paradigma's zijn imperatief programmeren en declaratief programmeren. Imperatief programmeren voert opeenvolgende verschillende statements uit die een interne \textit{state} veranderen (muteren). Bij declaratief programmeren specificeert de code wat er moet uitgevoerd worden maar niet hoe. Object-Oriented (Object-Geörienteerd) programmeren wordt geklasseerd onder imperatief programmeren. Objecten bundelen de verschillende statements en \textit{state} op een overzichtelijke manier.

\section{Object-Oriented programmeren}
\subsection{Achtergrond}
OOP is een manier van programmeren die in simpele zin werkt met objecten die onderling berichten versturen naar elkaar, ook wel bekend als \textit{message passing} \autocite{Armstrong2006}. Een object heeft \textit{state} (data in variabelen) en gedrag (methoden). Objecten communiceren met elkaar door methodes aan te roepen van andere objecten. OOP in talen zoals Java en C\# zijn klasse-gebaseerd, dit wil zeggen dat objecten aangemaakt worden via klassen. Klassen definiëren objecten die dezelfde \textit{state} en hetzelfde gedrag hebben en vormen een blauwdruk waarmee deze objecten kunnen aangemaakt worden tijdens de uitvoering van een programma en hebben een initiële \textit{state} waarmee een object begint bij de creatie ervan \autocite{Bruce2002}. Die creatie gebeurt door middel van een \textit{constructor} \autocite{OracleCorporation2019}.

\subsection{Concepten}
De concepten of soms ook bekend onder de naam 'pilaren' van OOP laten toe om code zodanig te structureren om het gebruik en onderhoud ervan te vergemakkelijken. Het toepassen van deze concepten wil nog niet zeggen dat de geschreven code goed is, correct gebruik van OOP hangt nog steeds af van het juist toepassen van de verschillende concepten aan de gepaste situaties. De vier bekendste concepten zijn Overerving, Abstractie, Polymorfisme en Encapsulatie \autocite{Armstrong2006}.

\begin{description}
   \item[Overerving] Ook wel bekend als specialisatie. Klassen kunnen overerven van andere klassen om zo uit te breiden (te specialiseren) op diens \textit{state} en gedrag. Zo kan bv. een klasse Student overerven van een klasse Persoon en uitbreiden op deze klasse met als extra \textit{state} een studentennummer en extra gedrag in de vorm van een methode 'studeren'. 
    Overerving laat hergebruik van klassen toe en kan een ontwikkelaar klassen naar wensen afstellen door deze uit te breiden. 
    \item[Abstractie] Abstracties maken van klassen simplificeren deze d.m.v. het verwijderen van details zodat een gebruiker een simpele weergave krijgt van een object zonder al de specifieke implementaties. Wanneer een object een methode aanroept op een ander wil deze vaak enkel een resultaat, voor het aanroepende object maakt het niet uit welke soort object het ander is, wat het allemaal kan of wat de implementatie van de aangeroepen methode is.
    \item[Polymorfisme] Dit concept stelt objecten in staat om te reageren op eenzelfde boodschap met eigen gedrag. Zo kan een object een methode aanroepen op een object en een resultaat terugkrijgen dat verschillend is als het dezelfde methode zou aanroepen op een ander object. Een algemene basisklasse declareert zo'n methode en andere klassen kunnen of moeten deze implementeren bij het uitbreiden van deze klasse. Dit duidt men vaak aan via een \textit{override} sleutelwoord. Een object die een andere object van die basisklasse bevat roept dan de methode aan en de runtime\footnote{Omgeving waar de uitvoering van een programma wordt geïmplementeerd.} \autocite{Aho1986} checkt welke implementatie er van toepassing is door te kijken naar het runtime type van het object, wat het type van één van de afgeleide objecten van de basisklasse zal zijn.
    \item[Encapsulatie] Encapsulatie breidt verder uit op abstractie door het afschermen van details die niet zichtbaar hoeven te zijn. Dit gebeurt a.d.h.v. \textit{access modifiers}. In Java zijn dit private, protected, package (default) en public \autocite{Deitel2015}. Een goede regel is om enkel zichtbaar te maken wat echt zichtbaar hoeft te zijn (dit zijn dan vaak methodes) en de onnodige details afschermen (vaak de variabelen). Toegang tot variabelen wordt afgeschermd door het sleutelwoord private zodat deze niet zichtbaar zijn voor de buitenwereld. Het aanpassen en opvragen van deze variabelen kan wel nog gebeuren via getters en setters, dit zijn methoden die de desbetreffende variabele controleren. Zo kan de buitenwereld nog steeds aan de variabelen maar heeft de klasse er meer controle over zodat er geen ongeldige waarden kunnen toegekend worden die kunnen leiden tot een onstabiel of onveilig programma.
\end{description}

\subsection{Design Patterns}
Design patterns zijn simpel gesteld kant-en-klare oplossingen voor specifieke problemen. In applicatieontwikkeling is het een best practice om te vermijden om het wiel te heruitvinden, daarom werden design patterns opgesteld om zo een referentie te bieden voor andere ontwikkelaars om een bepaalde probleem op te lossen. Want net zoals het herhalen van code herhalen problemen zich ook . OOP is niet perfect maar door de correcte implementatie van design patterns kan een ontwikkelaar het maximum halen uit de mogelijkheden van OOP zonder zichzelf tegen te werken door terug onoverzichtelijke code (bekend als spaghetticode) te schrijven. Hoewel er talloze design patterns bestaan zullen hier slechts enkele besproken worden die relevant zijn voor het onderzoek. Het voordeel ervan is dat deze patterns taalonafhankelijk zijn en dus vrijwel bij elke OOP gebaseerde taal gebruikt kunnen worden. Het juiste design pattern vinden voor een bepaalde probleem blijft één van de uitdagingen voor een OOP ontwikkelaar.

\begin{description}
  \item [Model-View-Controller] MVC is een pattern dat vooral betrekking heeft tot de opbouw van een applicatie met een user interface. Het koppelt de UI los van de domein logica d.m.v. een controller die zal zorgen voor de communicatie tussen Model (domein) en View. In kleine en simpele applicaties is dit vaak één zogenaamde \textit{domeincontroller} die de juiste objecten zal aanspreken om te voldoen aan de vragen die vanuit de UI komen. Op die manier is er voor de View slechts één aanspreekpunt en blijft de business logica afgeschermd.
  \item [Model-View-Viewmodel] Net als MVC is MVVM ook een architecturaal pattern. Hier zorgt het Viewmodel voor de ontkoppeling tussen Model en View door de (vaak afgeschermde) data van een Model bloot te stellen voor de View. Via \textit{data binding} koppelt de View zich dan aan de Viewmodel. Deze binding zorgt voor de synchronisatie van data tussen Viewmodel en View zodat steeds de meeste actuele data wordt getoond aan de gebruiker. Uiteraard worden enkel de nodige details van het Model blootgesteld aan de View door het ViewModel, dit werkt Encapsulatie in de hand.
  \item [Singleton] Het Singleton pattern zorgt ervoor dat er van één klasse slechts één instantie wordt aangemaakt en dat deze enkele instantie dus overal in de applicatie wordt gebruikt. Dit vermijd het onnodige aanmaken van 'dure' objecten en zorgt voor uniformiteit doorheen de applicatie doordat elk object werd met dezelfde singleton er dus geen onverwachte resultaten kunnen ontstaan die door het gebruik van meerdere instanties wel het geval kan zijn.
  % Overige patterns nog toevoegen?
\end{description}

\subsection{SOLID}
SOLID is een acronym dat de 5 principes van OOP (niet te verwarren met de eerder vermelde concepten/pillaren) omschrijft die werden opgesteld door Robert C. Martin \autocite{Buysse2017-2018}.  Het juist volgen van deze principes zorgt ook voor makkelijk onderhoudbare en uitbreidbare code. De principes zijn als volgt:
\begin{description}
  \item [Single responsibility principle] Elke klasse heeft maar één verantwoordelijkheid in een applicatie. Zo wordt het makkelijker om veranderingen aan te brengen in de code zonder neveneffecten. Het vermijd ook het maken van een \textit{god object} \autocite{Riel1996}, een object dat te veel doet en/of te veel weet.
  \item [Open-closed principle] Code moet open zijn voor uitbreidingen maar afgesloten voor wijzigingen. M.a.w. het moet mogelijk zijn om op een klasse, functie, etc. uit te breiden zonder daarvoor de originele code te moeten wijzigen. 
  \item [Liskov substitution principle] Waar men een bepaalde klasse verwacht daar moet een subklasse voor kunnen instaan. Een subklasse kan op een methode van een superklasse uitbreiden maar kan deze niet inperken. Zo moet de input (aantal en type van de parameters) en output (return type) hetzelfde blijven.
  \item [Interface segregation principle] Het correct volgen van dit principe vermijd het maken van te grote interfaces met methodes die dan een onnodige implementatie vereisen wanneer klasse slechts enkele methodes van deze interface nodig hebben.
  \item [Dependency inversion principle] Abstractie staat centraal bij dit principe. Een abstractie ontkoppelt \textit{dependencies} van elkaar en zorgt ervoor dat die enkel afhankelijk zijn van de abstractie, dus niet meer van de details van elkaar.
\end{description}

Correct gebruik van OOP kan leiden tot herbruikbare en makkelijk uitbreidbare code en dit voordeel heeft het laten uitgroeien tot het meest gebruikte programeerparadigma. Klassen zijn vaak afgeleid van objecten in de echte wereld en dit maakt het geheel makkelijk verstaanbaar en leesbaar. Aan OOP zijn er echter ook nadelen verbonden. Zo is er typisch veel code nodig bij een OOP aanpak en is die ook minder performant door de verschillende objecten die bij elkaar methodes aanroepen. Een ander nadeel is dat het zich niet zo goed leent bij parallelle processen doordat data in allerlei objecten verscholen zit en dus de \textit{state} van het programma continu door andere objecten kan veranderd worden. OOP is dus geen \textit{all-round} paradigma en ondanks zijn populariteit de voorbije decennia blijft het toch niet het enigste paradigma waarin ontwikkelaars programmeren. Functioneel programmeren is een paradigma dat aan populariteit blijft winnen en sterker is in de gebieden waar OOP tekort kan schieten (maar wel andere nadelen met zich mee kan brengen).

\section{Functioneel programmeren}
\subsection{Achtergrond}
Zoals de naam al doet vermoeden staan functies centraal bij FP. Functies nemen data als input en geven daarop een output terug zonder de originele data te veranderen. \textit{Immutability} \autocite{Goetz2006}, het niet muteren van variabelen, is dan ook zeer belangrijk binnen dit paradigma. Alhoewel functioneel programmeren nog maar recent aan populariteit wint is het concept toch al reeds bekend sinds de introductie van Lambdacalculus door Alonzo Church in de jaren 30 \autocite{Church1941}. Lambdacalculus maakt gebruikt van zogenaamde pure functies en vormt de basis voor het functioneel programmeren paradigma. Er bestaan talen specifiek gericht op die paradigma zoals Lisp, Scala, Haskell en Erlang. Ondersteuning voor FP kwam er ook talen voor zoals Java (lambda's en streams) en C\# (LINQ) maar dit wordt in de talen nog steeds gebruikt in combinatie met OOP. Deze functionaliteit wordt in die talen vooral gebruikt bij het werken met collecties zoals de \textit{map} en \textit{reduce} functies. Het enige wat een programmeertaal moet ondersteunen om aan FP te kunnen doen zijn zogenaamde \textit{higher-order functions} net zoals het geval is bij lambda calculus \autocite{Federale2019}. Hierdoor kan men ook gebruik maken van currying. Deze concepten van FP komen nu aan bod in volgende subsecties.

\subsection{Lambdacalculus}
Daar dit geen wiskundige paper is zal er niet diep worden ingegaan op de Lambdacalculus maar zal er slechts een korte uitleg volgen om de basis achter FP te illustreren. An sich is Lambdacalculus eigenlijk een programmeertaal, al is die \textit{low-level}. Lambdacalculus werkt met pure functies, deze krijgen een input en geven een output terug. Deze functies zijn puur omdat ze voor dezelfde input steeds dezelfde output teruggeven. De functies hebben een \textit{black box} structuur, het is dus niet geweten hoe die functies precies werken, enkel hun input en output is gekend. Dit leidt tot al één concept binnen FP; de focus op programmeren \textbf{wat} je wil bereiken en niet \textbf{hoe}. De input en output van functies binnen Lambdacalculus kunnen op hun beurt ook functies zijn, dit zijn dan de zogenaamde \textit{higher order functions}. Variabelen binnen Lambdacalculus zijn constant, ze veranderen dus niet en zijn m.a.w. \textit{immutable}.

\subsection{Functies in Functioneel Programmeren}
Functies vormen de bouwstenen in een applicatie met een FP stijl. Waar een applicatie in een OOP stijl ingedeeld is in klassen, is een applicatie in FP stijl opgedeeld in modules die elke een bepaalde functionaliteit van de applicatie groeperen. Modulariteit binnen een programma is handig voor het hergebruik van code en zorgt voor een structuur die flexibel is en makkelijk te onderhouden. 
De functies binnen FP moeten puur zijn, d.w.z. ze krijgen een input en geven voor één input één en dezelfde output. Deze pure functies hebben dus geen neveneffecten, ze beïnvloeden geen globale variabelen of andere soort van \textit{state}. Het testen van deze functies is dan ook zeer makkelijk aangezien ze bij dezelfde parameters telkens dezelfde output geven, zonder uitzondering.
Verder zijn deze functies ook zogenaamde \textit{higher-order} functies. Ze kunnen andere functies als argument nemen en/of een functie retourneren. Hiervoor is het vooral nodig dat de programmeertaal waarin een ontwikkelaar werkt \textit{first-class} functies ondersteunt, d.w.z. dat de taal functies behandelt net zoals alle andere types van data m.a.w. ze kunnen naast voorgenoemde toepassingen ook aangemaakt en opgeslagen worden in variabelen. Een niet-pure functie herkent men vooral aan een ontbreken van argumenten, het wijzigen van een globale \textit{state} of de afwezigheid van een return statement en bij het volgen van een pure FP aanpak zouden dit al tekens zijn dat de implementatie fout gaat.

\subsection{Currying}
Deze techniek is vernoemd naar Haskell Curry (wiens voornaam ook de naam is van de functionele programmeertaal). Het omvat een techniek waarmee men een functie die meerdere parameters heeft opsplitst in een sequentie van functies met telkens één parameter. Zo ontstaan er verschillende deelfuncties die kunnen opgeslagen worden in variabelen. Op die manier is het ook makkelijk om deze functies te hergebruiken in andere delen van de applicatie. Dit laat toe om zeer minieme functies te bouwen die makkelijk testbaar zijn en duidelijk in gedrag en in- en uitvoer. Deze minieme functies kunnen dan bouwstenen zijn voor grotere complexe functies, ondersteund door de zekerheid dat elk van die bouwstenen werken. Compositie van functies is dan ook een belangrijk concept binnen het functioneel programmeren. Currying werkt ook hand in hand met \textit{dependency injection}, wanneer je parameters van elders worden doorgegeven \autocite{Microsoft2019}.

\subsection{Immutable}
Nog een centraal concept binnen FP is \textit{immutable}, data die niet meer ongewijzigd blijft na initialisatie. Dit werkt hand-in-hand met het concept van pure functies, aangezien deze geen neveneffecten hebben en enkel output retourneren gebaseerd op hun input. Werken met \textit{immutable} data is vooral ideaal voor applicaties die gebruik maken van \textit{multithreading} en parallelle processen. Aangezien deze data niet verandert kunnen er zich ook geen problemen voordoen bij het gelijktijdige schrijfoperaties. Een applicatie werkt echter met data en deze data moet uiteindelijk ergens gemuteerd worden om op te slaan in een databank. Daarom zal er altijd een compromis gemaakt worden en zal er op (liefst) één plek toch data muteren die dan naar de databank wordt weggeschreven. De uitdaging bestaat er in dat dit gebeurt op een correcte manier en door deze handeling te beperken tot één plaats in de code heeft een ontwikkelaar daar meer controle over.

\subsection{Map en Reduce}
Binnen FP hebben loops geen plaats, aangezien dit meestal aanleiding geeft tot het muteren van \textit{state}. Naast het gebruik van recursie bestaan er binnen FP de functies \textit{map} en \textit{reduce}, twee functies die gebruikt kunnen worden om te werken met collecties. \textit{Map} verwacht een functie als parameter die op elk element zal uitgevoerd worden. \textit{Reduce} verwacht een functie en een initiële waarde en zal alle via die functie en waarde alle elementen verwerken tot één element. Deze twee functies lopen parallel met de gedachtegang van FP, de ontwikkelaar zal vooral specificeren wat hij wil doen maar niet hoe, de specifieke implementatie van deze functies speelt geen rol binnen de scope van de applicatie die de ontwikkelaar wil bouwen. Deze functies vormen de basis van andere vaak voorkomende functies om met collecties te werken zoals \textit{find}, \textit{filter}, \textit{any} e.a.

Functioneel programmeren wint alsmaar meer aan populariteit en dat is te zien aan de verschillende talen die dit (al dan niet gedeeltelijk) ondersteunen. Eén taal waarbij zowel OOP en FP mogelijk zijn op verschillende gradaties is JavaScript, dé programmeertaal voor webontwikkeling. Dankzij zijn vele frameworks en consistente verbeteringen is het dan ook één van de populairste talen op dit moment.

\section{JavaScript}
\subsection{Achtergrond}
Tijdens webontwikkeling komt een ontwikkelaar vroeg of laat in aanraking met JavaScript. Waar het vroeger voornamelijk werd gezien als een scripting taal om statische websites iets dynamischer te maken krijgt de taal nu alsmaar meer aandacht door het opkomen van allerlei innovatieve frameworks en de introductie van TypeScript (Microsoft) en Flow (Facebook) waarmee ontwikkelaars aan de slag kunnen met types binnen JavaScript. Standaard is JavaScript is een zwak en dynamisch getypeerde taal. Dynamisch wil zeggen dat het type wordt bepaald tijdens runtime op basis van de aarde van de variabele. Zwakke typering zorgt ervoor dat een variabele niet vasthangt aan één type, zo kan het op het ene moment een getal zijn, op het ander moment een string. De naamgelijkheid met Java is echter in het verleden enkel een manier geweest om van wat naambekendheid te profiteren, de twee talen hebben amper iets met elkaar te maken. Ontwikkelaars kunnen niet op dezelfde manier werken met Java als ze doen met JavaScript, zelfs op een OOP manier, door de minder stricte natuur van JavaScript. 

\subsection{EcmaScript}
EcmaScript is de standaard voor JavaScript die continu nieuwe features toevoegt aan de taal om deze steeds te verbeteren. EcmaScript 5 had een enorme invloed op de taal dankzij de vele verbeteringen die het introduceerde. Zo kwam er een klasse syntax inclusief getter en setters die het eenvoudiger maakte om met klassen en overerving te werken, import statements om externe modules in te laden, \textit{let} en \textit{const} om variabelen te declareren die \textit{block scope} hadden i.p.v. \textit{var} die \textit{function scoped} was, de \textit{spread} en \textit{rest} operators en nog veel meer. Toenmalige code werd al snel gedateerd door de introductie van deze features.

\subsection{Klassen}
Klassen werden geïntroduceerd in de EcmaScript 5 standaard waardoor het makkelijker werd om aan OOP te doen zoals ontwikkelaars gewend waren van talen zoals Java en C\#. Deze klassen werken echter niet helemaal zoals ze in die talen werken, dat blijkt aan het grote probleem met \textit{this}. Als \textit{this} voorkomt in een klasse dan verwijst die naar die specifieke klasse maar in JavaScript is dit soms niet geval zoals bv. bij event handling waar\textit{this} dan eerder naar het event verwijst dan naar de klasse. Dit zorgt vaak voor verwarring bij ontwikkelaars die een andere taal gewend zijn, maar ook bij een ervaren JavaScript ontwikkelaar blijft dit een probleem.

\subsection{Node.js}
JavaScript draaide origineel enkel binnen een browser en werd daarom enkel gebruikt voor frontend ontwikkeling. Hier kwam echter verandering in dankzij Node.js. Hiermee werd het ook mogelijk om JavaScript op een server te draaien met als gevolg dat de taal ook kon gebruikt worden voor backend ontwikkeling. Hoewel er veel externe libraries bestaan binnen de taal blijft Node.js één van de meest belangrijke die nog steeds relevant is en blijft gebruikt worden bij de ontwikkeling van nieuwe applicaties. Ook op het vlak van backendtechnologieën in het algemeen blijft het populair naast anderen zoals .NET. Een populair gebruik van Node.js is nog steeds de zogenaamde MEAN stack. Deze stack maakt gebruikt van MongoDB als database, Express als web applicatie framework, Angular voor frontend en tenslotte Node.js voor het gebruik van JavaScript aan de server side. Om het gebruik van MongoDB te ondersteunen gebruiken ontwikkelaars ook Mongoose, dit om te kunnen werken met schema's binnen MongoDB.

\subsection{React en Angular}
Deze populaire frameworks (opgericht door Facebook enerzijds en door Google anderzijds) zijn gericht op een componenten structuur om zo een applicatie modulair te maken, wat de verantwoordelijkheid van de functionaliteiten van de applicatie gaat verdelen over de verschillende gebruikte componenten. Dit heeft als gevolg dat de applicatie makkelijker testbaar en onderhoudbaar wordt. Doordat de componenten op meerdere verschillende plaatsen kunnen gebruikt worden maakt het de code ook herbruikbaar. 

\subsubsection{JSX}
React verwezenlijkt dit door het gebruik van JSX, een \textit{syntactic sugar} met een HTML/XML structuur. Het verduidelijkt de structuur van een user interface en combineert de vormgeving met de functionaliteit doordat er nog steeds JavaScript gebruikt kan worden in deze tags. Deze custom tags compileren dankzij Babel \footnote{compileert moderne JavaScript code naar backwards compatibele code} \autocite{Babel2019} naar functieaanroepen.
\begin{lstlisting}[caption=JSX compilatie]
  // component in JSX
  const component = <p className="helloWorld"> Hello, World! </p>;  

  // compilatie door Babel
  React.createComponent(
    'p',
    { className: 'helloWorld' },
    'Hello, World!'
    );
\end{lstlisting}
Deze functieaanroepen bevatten 3 argument: het soort component, de props (input) en de children van het component. Props (ofwel properties) is data die wordt meegegeven aan componenten zodat die zich daarop kunnen baseren om te weten hoe of wat ze moeten renderen. Het wijzigen van deze props zorgt voor het herrenderen van een component. Dit gebeurt via een algoritme waarbij er vergeleken wordt wat er gewijzigd is geweest en welke componenten opnieuw moeten renderen. 

\subsubsection{Componenten in React}
Componenten in React kunnen zowel met klassen of functies gemaakt worden. Een klasse component heeft minstens een render methode die een component teruggeeft in ofwel JSX of door de functieaanroepen te gebruiken.  Daarnaast kan zo'n klasse ook andere functies bevatten en heeft die toegang tot een interne \textit{state} waarin variabelen worden opgeslagen. Analoog aan het wijzigen van props zorgt het wijzigen van state er ook voor het herrenderen van een component. Van de klasse wordt wel verwacht dat het de Component klasse van React uitbreidt (door overerving). Klassecomponenten hebben toegang tot de \textit{lifecycle} methoden van een React component zoals componentDidMount en componentDidUpdate. Hiermee kan bepaald gedrag worden uitgevoerd bij het aanmaken van de component of wanneer deze opnieuw wordt gerenderd.

\begin{lstlisting}[caption=Klassecomponent]
  class HelloWorld extends React.Component {
    componentDidMount() {
      console.log('HelloWorld component was mounted!');
    }

    render() {
      return (
        <p> Hello, World! </p>
      );
    }
  }
\end{lstlisting}

Een component die aangemaakt wordt door middel van een functie heet een functionele component. Dit is eenvoudigweg een functie die een component teruggeeft. Deze functies hebben slechts 1 argument, de props. Het meegeven van dezelfde props zorgt voor het weergeven van dezelfde component, zo is een functionele component dus een pure functie doordat er geen neveneffecten aan te pas komen. Het gebruik van deze componenten laten ontwikkelaars toe om te programmeren binnen JavaScript met een meer functionele aanpak. De code van deze componenten is ook vaak korter dan hun klasse tegenverwanten en leesbaarder. Deze componenten hebben wel geen toegang tot de \textit{lifecycle} methoden van React component zoals het geval is bij klassecomponenten. Functionele componenten kunnen ook typisch geen gebruik maken van een interne state, maar sinds React 16.8 kan binnen deze componenten gebruik gemaakt worden van Hooks die dit probleem oplossen. 

\subsubsection{Hooks}
Dit zijn functies waarmee je toch state kan bijhouden binnen een functionele componenten. Daarnaast laat het ook toe om andere neveneffecten te gebruiken in zo'n component. Deze neveneffecten zorgen er wel voor dat de functionele component niet meer puur is aangezien wat er gerenderd wordt niet meer enkel afhankelijk is van de inkomende props. Hooks zorgen wel voor een brug tussen de \textit{stateless} wereld van functionele componenten en de vaak state-bevattende user interface. Deze state blijft echter wel intern voor de functie die ze gebruikt, deze is niet globaal zodat andere componenten hier geen toegang tot hebben en vermijd de mogelijkheid tot het wijzigen van deze state van buitenaf.

\subsubsection{DOM}
React simplificeert één van de moeilijkste kanten van webontwikkeling: werken met het DOM \footnote{Document Object Model: Geeft scripts en programma's toegang om de inhoud van een (web)document dynamisch aan te passen onafhankelijk van taal of platform}. De oplossing van React hiervoor is een eigen DOM waar het gebruik van maakt om UI's te renderen. Elk component binnen React krijgt \textit{props} binnen van buitenaf en heeft al dan niet interne \textit{state}. Als één van deze twee veranderen dan rendert de component opnieuw in de applicatie zodat die steeds geüpdatet blijft en niet statisch. 

Naast React bestaat er ook nog React Native, een taal die het mogelijk maakt om met React mobiele applicaties te schrijven voor zowel Android als iOS. De werking blijft grotendeels hetzelfde in vergelijking met de gewone React API, met uitzondering van de afwezigheid van HTML tags en dat sommige externe modules niet ondersteund worden, maar de JavaScript code wordt omgezet naar native iOS en/of Android code. Zo wordt de applicatie op beide platformen tegelijk ontwikkeld, wat vaak tijdsbesparend kan werken maar ook zijn eigen complicaties met zich meebrengt.

\subsubsection{Angular Modules}
Angular is vooral populair voor \textit{Single Page Applications}. Zo draait een applicatie op slechts één pagina in de browser maar heeft die toch nog een dynamische UI. Zo een Angular applicatie is opgedeeld in modules, met op zijn minst al de \textit{root module} van de applicatie, deze zorgt voor het opstarten van de applicatie. Deze modules kunnen functionaliteit van andere modules importeren en hun eigen functionaliteit exporteren. Welke modules, componenten en andere onderdelen van Angular applicatie behoren tot deze module wordt declareerd binnen de module zelf. De modules zorgen ook voor de dependency injection van services voor de componenten die ze beheert, vanuit deze services halen componenten vaak hun data of andere functionaliteiten zoals het geval is bij de Angular Router module voor navigatie binnen een single page application en de HttpClient voor het afhandelen van HTTP requests maar ook nog andere diensten zoals authorisatie en authenticatie kunnen tot deze services behoren. De dependency injection van de modules zorgt ervoor dat deze componenten niet zelf hun services moeten aanmaken en dat elke component binnen deze module met dezelfde services werkt (zoals het Singleton pattern). 

\subsubsection{Componenten in Angular}
Een component in Angular bestaat uit 3 delen: de HTML (weergave), de CSS (opmaak) en het JavaScript (dynamisch) gedeelte. Het JavaScript gedeelte van zo'n component bestaat uit een ES6 klasse. Het framework maakt vooral gebruik van het Model-View-Viewmodel (MVVM) patroon door data binding. Zo wordt een View (de HTML) verbonden met het Viewmodel (JavaScript) die vaak een Model (data) heeft en die bepaalde eigenschappen van die data zal blootstellen aan de HTML code. D.m.v. data binding blijft de data die wordt weergegeven in de HTML pagina gesynchroniseerd en actueel. Zo'n Model kan voorgesteld worden door middel van een klasse, wat een OOP aanpak aanmoedigt. De component bevat dan een instantie van deze klasse en definiëert zelf methoden waarin de waarde van variabelen binnenin die instantie worden opgevraagd of ingesteld of waarin de methoden van deze instantie worden aangeroepen. Zo kan een View niet rechtstreeks aan het Model en moet deze altijd via de component gaan, het Viewmodel. Dit werkt encapsulatie in de hand, opnieuw een voordeel om met OOP te werken.

\subsubsection{Services}
Componenten binnen een Angular applicatie beheren vooral de user interface, enige andere data of functionaliteit die ze hiervoor nodig hebben kunnen ze delegeren aan services. Via een Injector injecteert Angular deze services in de componenten die er gebruik van maken. 

\subsubsection{Directives}
Naast de standaard HTML tags komen er bij Angular extra tags bij, de de zogenaamde \textit{directives}. Deze directives breiden standaard HTML tags uit (m.a.w. overerving), dit vormt de basis van de werking van Angular. Zo toont een tag met een ng-if directive enkel zich enkel als het voldoet aan een conditie. Als men die conditie bind aan een property die wordt blootgesteld in het Viewmodel dan zal deze component zich automatisch tonen of verbergen naargelang de property verandert door een handeling binnen de code.  

\subsection{Object Oriented}
JavaScript is een \textit{multiparadigm} taal, dus het kan zowel gebruikt worden bij een OOP als een FP aanpak \autocite{Atencio2016}. Als je met objecten werkt binnen JavaScript is dit echter niet hetzelfde zoals je bij andere talen zou verwachten. Hoewel klassen werden geïntroduceerd in de EcmaScript 5 standaard blijft JavaScript een \textit{prototype based} OOP taal \autocite{Blaschek1994}. Dit betekent dat alle objecten een prototype als property hebben waarbij reeds methodes en \textit{state} horen (dit is overerving). Dit werkt niet hetzelfde als met klassen, aangezien tijdens \textit{runtime} het prototype van een object kan veranderen zodat deze een ander gedrag en \textit{state} kan hebben. Om uit te breiden op een object moeten de gewenste methoden en \textit{state} worden toegevoegd aan hun prototype. Indien een ander object hetzelfde gedrag en \textit{state} wil van een ander object dan kan het prototype van dit object ingesteld worden met een prototype van het ander. Alle objecten hun prototype zijn afgeleid van het Object object, wiens eigen protoptype verwijst naar \textit{null}. Dankzij de introductie van klassen in ES5 komen JavaScript nog maar weinig in aanraking met het \textit{prototype} aspect van de taal maar dit is slechts een verkorte syntax, achter de schermen wordt er nog steeds gewerkt met prototype hoewel de code al meer lijkt op klassen die je vindt in bv. een Java applicatie. Een object is ook heel verschillend van andere OOP talen en werkt eerder als een key/value verzameling, een associatieve array. Velden binnen dit object worden niet vooraf gedefinieerd en kunnen zo worden toegevoegd tijdens \textit{runtime}. Deze objecten hebben geen type en worden dus niet vooraf gedefinieerd in een klasse. Dit verschil in aanpak van OOP blijft een struikelblok voor ontwikkelaars en daarom wordt er meer aangeraden om binnen JavaScript te werken met het FP paradigma. Het Angular framework gaat nauw samen met OOP doordat de basis al ligt in één van de hoofdconcepten: Overerving. De directives binnen Angular erven over van standaard HTML tags en stellen ontwikkelaars zo in staat om dynamische Single Page Applications te creeëren a.d.h.v. HTML en JavaScript.

\subsection{Functioneel}
Functioneel programmeren is al mogelijk sinds de conceptie van JavaScript, omdat de taal gebaseerd is op \textit{Scheme}, een FP taal. Functies binnen JavaScript zijn \textit{first class objects} en de taal ondersteunt daarmee dus ook \textit{higher order} functies. Zo beschikt de taal over al het nodige om aan FP te doen maar is het nog steeds niet verplicht om enkel op die manier te werken. Het brengt wel een aantal voordelen met zich mee zoals niet meer afhankelijk zijn van de soms onverwachte resultaten door het gebruik van prototype en \textit{this}. Het maakt de code ook makkelijk herbruikbaar en modulair door hergebruik van functies. Data binnen JavaScript is niet altijd immutable. Zo zijn er nog steeds de declaraties \textit{var} en \textit{let} van welke de waarde mogen veranderen maar ook \textit{const} is niet volledig immutable. Als een constante verwijst naar een object in JavaScript dan kan dat object muteren, enkel de verwijzing naar het object zelf kan niet wijzigen. Om echt immutable data te gebruiken heeft men binnen JavaScript nood aan een externe library, zoals bv. Immutable.js (ontwikkeld door Facebook). Andere externe modules kunnen ook het gebruik van een FP aanpak binnen JavaScript ondersteunen zoals Ramda en Lodash.

Binnen React wordt er aangeraden om vooral te werken met functionele componenten vanwege de performantie die komt van het gebruik van deze componenten. Aangezien dit an sich gewoon functies zijn worden deze opnieuw aangeroepen telkens de meegegeven props wijzigen. Werken met klassen is vanwege de verschillende \textit{lifecycle} methods ook vaak een anti-pattern. Hoewel deze klassen nooit zullen verwijderd worden van de React API is er toch steeds meer een beweging aan het gebeuren richting de functionele kant van JavaScript, zeker na de introductie van Hooks voor het beheer van state en andere neveneffecten binnen functionele componenten. Door het gebruik van functionele componenten wordt één van de principes van FP toegepast: pure functies. Deze functionele componenten zijn enkel afhankelijk van hun props, de input, en niet nog van een interne \textit{state} of andere zaken waardoor er neveneffecten kunnen ontstaan. Door de afwezigheid van neveneffecten zijn deze componenten testbaarder en ook leesbaarder doordat ze vaak korter zijn dan hun klassetegenhangers. Immutability komt ook van pas bij React. Het herrenderen van een component gebeurt door te kijken of de binnenkomende props wijzigen. Met immutable props kan er snel gekeken worden of deze inderdaad veranderd zijn zonder intern te moeten kijken naar properties van objecten of items in arrays, wat bij complexe constructies tijd kan besparen. Voor sommige specifieke situaties is het echter nog steeds nodig om een klassecomponent te gebruiken in plaats van een functionele.