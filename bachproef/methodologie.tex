%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

\section{Voorbereiding}
 Beide frontend applicaties maken gebruik van puur JavaScript, zonder het gebruik van externe libraries of frameworks zoals jQuery, React of Angular. Er werd enkel gebruik gemaakt van Webpack voor het bundelen van de code en het opzetten van een live dev server om de applicatieontwikkeling te ondersteunen en van Babel. De applicatieontwikkeling bestaat uit vier delen: twee applicaties, één met een OOP aanpak en de ander met een FP aanpak, elk met een frontend en backend gedeelte. Er werd gekozen om beide aspecten te ontwikkelen zodat er ook op dat niveau een vergelijking mogelijk is tussen frontend en backend in zowel OOP als FP. Frontend technieken met backend vergelijken is irrelevant en enkel één van beide vergelijken geeft een te oppervlakkig beeld van de voordelen en nadelen van beide paradigma's. De applicatie die ontwikkeld werd is een applicatie voor drummers. Voor het uiteindelijke ontwikkelen van de applicatie werd eerst een UML*FOOTER* diagram aangemaakt om de verschillende klassen te illustreren. Dit is voornamelijk voor de OOP applicatie. Een metronoom heeft een tempo en soort geluid en kan gestart en gestopt worden. Een rudiment heeft een naam en een sticking (hoe de oefening moet uitgevoerd worden) en methodes voor het beheren van zijn practice sessions. Deze practice sessions hebben een tempo en een tijdsduur. Voor de user interface van de applicatie komt een metronoom aan te pas die ingesteld wordt aan de hand van een slider voor het tempo, een select veld voor het type geluid en een knop om de metronoom te starten en te stoppen. Verder is er ook een beheersysteem om de vooruitgang te volgen in bepaalde drumoefeningen, rudiments genaamd. Met een zoekveld kan er gezocht worden tussen de verschillende oefeningen. Wanneer er een oefening geselecteerd wordt en de metronoom wordt gestart dan zal de vooruitgang gevolgd worden en opgeslagen.

\section{Uitvoering}
Voor beide applicaties werd er eerst een standaard project aangemaakt met behulp van Webpack en Babel. Het opzetten van het project gebeurde met NPM, gebruik makende van het commando \textit{npm init}. Hierna werd aan beide projecten een config bestand voor zowel Webpack als Babel toegevoegd waarin o.a. de configuratie staat voor de live dev server. Vervolgens werd er een HTML pagina aangemaakt, deze is identiek voor beide applicaties. Enkel het JavaScript gedeelte verschilt. Voor de OOP applicatie werden hiervoor eerst modellen gemaakt door middel van het creëren van klassen. Deze klassen zijn Metronome, Rudiment, PracticeSession en Stopwatch. Deze zullen de business logica van de applicatie bevatten. PracticeSession bevat enkel data (een tempo en een duration veld) maar de andere klassen bevatten ook methoden (zoals start en stop bij Metronome en hoe toevoegen of verwijderen van PracticeSessions bij Rudiment).
Voor de FP applicatie werd alvast een compose methode aangemaakt, deze vergemakkelijkt het samenstellen van (pure) functies die opeenvolgende worden uitgevoerd met het resultaat van de functie ervoor. Dit is een higher order functie aangezien de functie zelf een functie retourneert. De functie neemt een onbepaalde aantal functies als argument, keert deze volgorde om, en retourneert dan een functie die een onbepaald aantal argumenten heeft. Deze geretourneerde functie zal via een reduce functie de lijst van functies toepassen, waarvan de eerste aangeroepen functie de argumenten meekrijgt die werden meegeven en de volgende functies zullen telkens het resultaat van de vorige meekrijgen als argument.

 \subsection{Metronoom}
 Het eerste onderdeel dat werd geïmplementeerd was de metronoom. Er werd eerst een MetronoomController gecreëerd, deze zal de koppeling vormen tussen View en Model. De Controller zal deze instantie van Metronome beheren zonder dat de View eraan kan (hier wordt er dus gebruik gemaakt van het facade pattern). Deze controller krijgt een aantal HTML elementen en maakt daar event listeners op aan zodat de Controller kan reageren op handelingen vanuit de user interface. Voor de implementatie van de user interface moest een label continu geüpdatet worden aan de hand van de huidige waarde van een slider. Verder moest ook een knop geïmplementeerd worden om de metronoom te doen starten en stoppen en moest een select lijst opgevuld worden met de verschillende mogelijke geluiden van een metronoom. Voor de OOP applicatie werd hiervoor de klasse Metronome gebruikt, waarvan de applicatie een instantie aanmaakt. Aan de slider werd een event listener verbonden die het tempo van de het Metronome object instelt en het label update zodat de user interface continu het juiste huidige tempo weergeeft. Duwen op de knop roept een methode op van de Metronome. Eerst kijkt de applicatie naar het \textit{playing} veld van het Metronome object, dit veld geeft aan of de metronoom al dan niet al aan het spelen is. Indien niet dan wordt de play methode aangeroepen en begint de metronoom te spelen door middel van de setInterval methode die tijdens elk interval een functie aanroept (in dit geval het tikken van de metronoom). Als de metronoom niet aan het spelen is dan wordt de stopfunctie aangeroepen, deze verwijdert het lopende interval. Bij het select input veld werd eerst de lijst aangevuld met de beschikbare opties. Een enumeratie (enum) *FOOTER* houdt de verschillende mogelijk geluiden bij. Daar een enum type niet bestaat in puur JavaScript werd er gebruik gemaakt van de Object.freeze methode, deze sluit het meegegeven object af voor wijzigingen. Vervolgens itereert de controller over dit object door middel van een for...in loop, deze zal alle properties van het object doorlopen. Voor elke property maakt de controller dan een gepaste HTML node aan, in dit geval een option node. Daaraan hangt de controller dan tekst en hangt de volledige node dan aan het select input veld. Aan dit veld voegt de controller dan nog een event listener toe die bij het selecteren van een optie het sound veld van het Metronome object zal instellen met de gekozen waarde.
 Voor de FP applicatie bleek dit een moeilijk onderdeel om te implementeren. FP draait nu eenmaal rond pure functies, maar voor de metronoom is er geen input data en moet er ook niets geretourneerd worden. Dit onderdeel bestaat voornamelijk uit neveneffecten zoals het instellen van een veld van de user interface, het spelen en stoppen van de metronome etc., iets wat niet past bij een functionele aanpak. Analoog aan de OOP aanpak voegt de applicatie een event listener toe aan de slider zodat het label kan ingesteld worden met de juiste tempo waarde. Voor het spelen van de metronoom moet ook nog een regel van FP gebroken worden: immutability. Het spelen van de metronoom maakt weer gebruik van de setInterval functie. Dit interval moet bijgehouden worden zodat het bij het stoppen van de metronoom kan verwijderd worden. Hiervoor maakt de applicatie gebruik van een \textit{let} variabele, die muteerbaar is en dus een regel breekt van het functioneel programmeren. De staat van spelen van de metronoom houdt de applicatie ook niet bij, hiervoor is de applicatie afhankelijk van de tekst in de knop. Als deze op 'Play' staat dan is de metronoom niet aan het spelen, bij 'Stop' speelt deze dan weer wel. Dit maakt de applicatie echter afhankelijk van de View, wat geen best practice is aangezien deze beter losgekoppeld is van de logica. Het aanvullen van het select input veld met de verschillende geluidsopties is dan weer wel iets dan goed werkt binnen de FP applicatie. De applicatie itereert over de waarden van de makeshift enum en roept hierop de map functie aan. Aan de map functie wordt dan een pure functie meegegeven die als input de string waarde van het geluid meekrijgt en als output een HTML element. Zo zal er voor elke waarde een HTML element aangemaakt worden en geeft de map functie dan een nieuwe lijst terug met deze elementen. Vervolgens vult de applicatie het select input veld op via de forEach functie die over de lijst itereert en een functie meekrijgt. Deze keer is dit geen pure functie, maar dit is een uitzondering die moet gemaakt worden om de View te kunnen wijzigen.

 \subsection{Lijst van Rudiments}
 Dit onderdeel bestaat uit een lijst van rudiments met een tekstveld waarop de lijst kan gefilterd worden. Hiervoor staat in de HTML een input tekstveld klaar en een leeg HTML lijstelement (ul). Om in de OOP applicatie deze lijst van rudiments te beheren werd er opnieuw een controller gemaakt, RudimentController, die de rudiments zal opvragen van de backend en bijhouden. De controller krijgt het HTML lijstelement mee via de constructor en kan zo hier de aparte elementen voor elk rudiment aanhangen. Dit gebeurt via een showRudiments functie die over de lijst van rudiments zal itereren en per rudiment een HTML element aanmaken. Vervolgens hangt de controller deze elementen aan het lege HTML lijstelement dat hij meekreeg via zijn constructor. Voor de implementatie van de filter werd er een eventlistener toegevoegd aan het input tekstveld. Bij het veranderen van de input (dus wanneer er getypt wordt bv.) zal de applicatie de showRudiments functie opnieuw aanroepen. Deze wordt werd uitgebreid met een filter argument en nog een extra instructie die voor het aanmaken van de elementen eerst nog over de lijst itereert en de naam van het rudiment vergelijk met de tekst van de filter. Als de filtertekst voorkomt in de naam dan zal het rudiment toegevoegd worden aan een filteredRudiments array. De controller itereert dan over deze array zodat de View steeds de juiste rudiments toont op basis van de filtertekst in het input veld.

De implementatie van dit onderdeel verreist het verwerken van een lijst met data, wat een sterkte is van functioneel programmeren. Voor het opvullen van het HTML lijstelement gebruiken we de compose methode, deze zal een reeks functies uitvoeren met als beginnend argument een lijst data die rudiments bevat. Als eerste functie roept geeft de applicatie een getItemNodes functie mee. Deze methode maakt gebruik van currying zodat er eerst een aantal argument kunnen meegeven worden. De functie zal telkens opnieuw een functie teruggeven tot de applicatie de lijst van rudiments meegeeft, waarna de functie het echte werk doet met behulp van de voorgaande argumenten. Als eerste argument krijgt getItemNodes een mapFunctie mee die zal bepalen hoe elk item gemapt zal worden naar een HTML element. Voor deze mapFunctie geeft de applicatie de functie createRudimentListNode mee, deze verwacht als argument een rudiment en maakt hiervoor de nodig HTML elementen aan en geeft deze dan terug. Voorlopig is dit een lijstelement die een tekstnode bevat waarin de details van het rudiment staan (naam en sticking). Als tweede argument voor de compose functie geeft de applicatie de appendToDomElement functie mee. Deze maakt weer gebruik van currying en verwacht als eerste argument een DOM element waaraan het items zal aan toevoegen. Deze items zijn dan ook het tweede argument van deze functie. De compose functie met de argument getItemNodes en appendToDomElement geeft dan opnieuw een functie terug die het beginnende argument verwacht, dit is de lijst met rudiments. Vervolgens zal deze lijst doorgegeven worden aan de getItemNodes functie die zijn mapFunctie argument zal toepassen op deze items en het resultaat retourneren. Dit resultaat, de lijst van HTML elementen, wordt op zijn beurt doorgegeven aan de appendToDomElement zodat de functie deze elementen toevoegt aan zijn DOM element argument. Deze compositie van functies is makkelijk herbruikbaar en zal dan ook hergebruikt worden voor het volgende onderdeel.

 \subsection{Lijst van Practice Sessions}
 