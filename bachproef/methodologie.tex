%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

\section{Voorbereiding}
Voor de functionele frontend werd gebruik gemaakt van het React framework, daar dit zich het best leent aan een functionele aanpak en deze aanpak ook wordt aangeraden door de React community. Deze frontend zal gebruik maken van puur JavaScript. Voor de frontend met een OOP aanpak werd gebruikt gemaakt van het Angular framework. Deze applicatie werd ontwikkeld met TypeScript aangezien dit de standaard is om met Angular te werken.

\subsection{Verloop}
De applicatieontwikkeling bestaat uit vier delen: twee applicaties, één met een OOP aanpak en de ander met een FP aanpak, elk met een frontend en backend gedeelte. Er werd gekozen om beide aspecten te ontwikkelen zodat er ook op dat niveau een vergelijking mogelijk is tussen frontend en backend in zowel OOP als FP. Frontend technieken met backend vergelijken is irrelevant en enkel één van beide vergelijken geeft een te oppervlakkig beeld van de voordelen en nadelen van beide paradigma's. De applicatie die ontwikkeld werd is een applicatie voor drummers. Hier komt een metronoom aan te pas die ingesteld wordt aan de hand van een slider voor het tempo, een select veld voor het type geluid en een knop om de metronoom te starten en te stoppen. Verder is er ook een beheersysteem om je vooruitgang te volgen in bepaalde drumoefeningen, rudiments genaamd. Met een zoekveld kan er gezocht worden tussen de verschillende oefeningen. Wanneer er een oefening geselecteerd wordt en de metronoom wordt gestart dan zal de vooruitgang gevolgd worden en opgeslaan. Het opslaan van deze data gebeurt in Angular via services en voor React via een combinatie van Hooks en higher-order components die de brug zullen slaan tussen de stateless natuur van functioneel programmeren en de state van een databank.

\section{Uitvoering}
 Er werd eerst een frontend applicatie aangemaakt in Angular, dit is vrij eenvoudig met de angular-cli en het commando \textit{ng create frontend-angular}. Zo werd een er project opgezet in TypeScript met o.a. de root module en een App component om het project op te starten. Analoog werd er voor de frontend in React ook een project aangemaakt met \textit{npx create-react-app frontend-react}. Zo werd er een project opgezet in JavaScript met een App component om het project op te starten. 

 \subsection{Metronoom}
 Het eerste onderdeel dat werd geïmplementeerd was de metronoom. Voor Angular omvatte dit het crëeren van een klasse Metronoom die de business logica van de metronoom zal bevatten, zoals tempo, soort geluid en of de metronoom aan het spelen is of niet. De metronoom component bevatte dan een instantie van dit model en definieert methoden waarmee de state en methoden van het model kunnen opgehaald, ingesteld of aangeroepen worden. Het HTML gedeelte van deze component bevat dan drie input velden: de slider van het type range, de knop van het type button en een select veld met de soorten geluid waarmee de metronoom kan ingesteld worden. Data-binding verbind deze input velden met de methodes van het JavaScript gedeelte van de component die toegang hebben tot de instantie van het model. Zo kan de view zowel de huidige state opvragen als instellen en de metronoom laten spelen en stoppen zonder zelf toegang te hebben tot het model.
 Voor React omvatte dit enkel het crëeren van een functionele component. Deze rendert de input velden analoog aan de implementatie in React en beheert zijn interne state via het gebruik van Hooks. De \textit{useState} Hook werd gebruikt om de waarden van tempo en type geluid te beheren. Deze methode geeft een waarde terug samen met een setter voor die waarde. Bij de onChange props van de input velden wordt deze setter dan meegegeven zodat de waarden worden ingesteld met wat er is gekozen. Zo wordt de component bij het wijzigen van deze input velden telkens opnieuw gerenderd zodat de meeste actuele state wordt getoond.

 \subsection{Lijst van Rudiments}
 Dit onderdeel bestaat uit een lijst van rudiments met een tekstveld waarop de lijst kan gefilterd worden. Voor Angular werd er eerst weer een model gemaakt van een rudiment, momenteel bevat deze klasse enkel nog een name als string. Voor het ophalen van deze rudiments werd er een service aangemaakt. Dit gebeurde via het commando \textit{ng generate service RudimentService}. De data voor deze rudiments werd momenteel nog \textit{hard-coded} in de service gestoken. Daarna werd er weer een component gemaakt genaamd RudimentList. Deze component houdt een lijst van rudiments die zal opgevuld worden met rudiments opgevraagd via de RudimentService. Naast de lijst van rudiments houdt deze component ook nog een filter bij van het type tekst waarmee de rudiments zullen gefilterd worden. Voor dit filteren werd een Pipe aangemaakt met het commando \textit{ng generate pipe FilterList}. Deze loopt een lijst van strings af en vergelijkt deze met de filter. Als op zijn minst een deel van de filter aanwezig in die string dan zal hij toegevoegd worden aan een gefilterde lijst, die op het einde van de functie zal teruggeven worden. In die view wordt een lijst gemaakt met behulp van het \textit{*ngFor} directive. Dit laat toe om verschillende componenten te laten aanmaken voor elk element in een lijst. De pipe wordt dan toegepast op deze lijst met de filter uit de RudimentList component. Als de filter gewijzigd wordt dan zal de pipe zijn werk doen en de meegegeven lijst filteren. Om de filter in te stellen werd gebruik gemaakt van een tekstveld die via het \textit{keyup} event de filter zal instellen met de waarde die werd ingetypt. Zo werd een lijst verkregen die meteen gefiltered wordt bij het intypen van tekst in het tekstveld.

 Voor React werd er opnieuw een component aangemaakt en werd er voor de filter opnieuw gebruik gemaakt van de \textit{useState} Hook. De setter werd opnieuw meegegeven aan de onChange prop van het tekstveld. De waarde werd dan gebruikt om de lijst te filteren. Dit gebeurde via de filter methode die kan aangeroepen worden op een lijst en waarbij een methode wordt meegegeven die true of false teruggeeft. Bij true wordt de waarde in een nieuwe lijst gestoken, bij false niet. Deze methode retourneert dan de nieuwe lijst. Op deze nieuwe lijst werd dan de map methode aangeroepen. Deze verwacht een functie waarvan de returnwaarde in een nieuwe lijst wordt gestopt. De returnwaarde van elk element bestond uit een React element zodat deze kan weergegeven worden. Als React een lijst krijgt met React elementen dan weet deze dat hij die één voor één moet renderen. Het enige wat verreist is, is een unieke key per element. Bij het wijzigen van de lijst kan er dan eenvoudig naar de key gekeken worden om te weten of dit element gerenderd moet worden of niet. Dit opeenvolgende aanroepen van de filter functie en de map funtie heet \textit{chaining}. Zo worden de lijst de teruggeven worden niet eerst nog opgeslaan in een variabele, wat de code compact maakt en makkelijk leesbaar. Bovendien zijn de functies die als parameter meegeven worden aan map en filter pure functies, ze retourneren dus altijd dezelfde waarde voor dezelfde input. Dit is de kracht van functioneel programmeren en die voorspelbaarheid maakt het makkelijk om fouten op te sporen die zich mogelijks voordoen. Boven hangt de filter functie af van de waarde van filter, dus bij het wijzigen hiervan zullen de functies opnieuw uitgevoerd worden en zal de lijst opnieuw gerenderd worden zodat bij het intypen van de filteren meteen het resultaat zichtbaar is.

\subsection{Object-Oriented Frontend}
\subsection{Object-Oriented Backend}
\subsection{Functioneel Frontend}
\subsection{Functioneel Backend}