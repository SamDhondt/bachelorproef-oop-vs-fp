%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

\section{Voorbereiding}
 Beide frontend applicaties maken gebruik van puur JavaScript, zonder het gebruik van externe libraries of frameworks zoals jQuery, React of Angular. Er werd enkel gebruik gemaakt van Webpack voor het bundelen van de code en het opzetten van een live dev server om de applicatieontwikkeling te ondersteunen en van Babel. De applicatieontwikkeling bestaat uit vier delen: twee applicaties, één met een OOP aanpak en de ander met een FP aanpak, elk met een frontend en backend gedeelte. Er werd gekozen om beide aspecten te ontwikkelen zodat er ook op dat niveau een vergelijking mogelijk is tussen frontend en backend in zowel OOP als FP. Frontend technieken met backend vergelijken is irrelevant en enkel één van beide vergelijken geeft een te oppervlakkig beeld van de voordelen en nadelen van beide paradigma's. De applicatie die ontwikkeld werd is een applicatie voor drummers. Voor het uiteindelijke ontwikkelen van de applicatie werd eerst een UML*FOOTER* diagram aangemaakt om de verschillende klassen te illustreren. Dit is voornamelijk voor de OOP applicatie. Een metronoom heeft een tempo en soort geluid en kan gestart en gestopt worden. Een rudiment heeft een naam en een sticking (hoe de oefening moet uitgevoerd worden) en methodes voor het beheren van zijn practice sessions. Deze practice sessions hebben een tempo en een tijdsduur. Voor de user interface van de applicatie komt een metronoom aan te pas die ingesteld wordt aan de hand van een slider voor het tempo, een select veld voor het type geluid en een knop om de metronoom te starten en te stoppen. Verder is er ook een beheersysteem om de vooruitgang te volgen in bepaalde drumoefeningen, rudiments genaamd. Met een zoekveld kan er gezocht worden tussen de verschillende oefeningen. Wanneer er een oefening geselecteerd wordt en de metronoom wordt gestart dan zal de vooruitgang gevolgd worden en opgeslagen.
 Analoog aan de frontend applicaties gebruikt de backend ook enkel puur JavaScript. Alle libraries die de ene applicatie gebruikt, gebruikt de andere applicatie uit, niet meer of minder. Dit maakt het mogelijk om een eerlijke en duidelijke vergelijking te maken. 

\section{Uitvoering}
Voor beide applicaties werd er eerst een standaard project aangemaakt met behulp van Webpack en Babel. Het opzetten van het project gebeurde met NPM, gebruik makende van het commando \textit{npm init}. Hierna werd aan beide projecten een config bestand voor zowel Webpack als Babel toegevoegd waarin o.a. de configuratie staat voor de live dev server. Vervolgens werd er een HTML pagina aangemaakt, deze is identiek voor beide applicaties. Enkel het JavaScript gedeelte verschilt. Voor de OOP frontend applicatie werden hiervoor eerst modellen gemaakt door middel van het creëren van klassen. Deze klassen zijn Metronome, Rudiment, PracticeSession en Stopwatch. Deze zullen de business logica van de applicatie bevatten. PracticeSession bevat enkel data (een tempo en een duration veld) maar de andere klassen bevatten ook methoden (zoals start en stop bij Metronome en hoe toevoegen of verwijderen van PracticeSessions bij Rudiment). Aangezien de data vanuit de backend komt in JSON formaat Om de klasse objecte krijgen deze klassen twee extra functies. De fromJSON functie is een static functie om JSON naar een instantie van een klasse om te zetten. Daar deze static is kan de functie aangeroepen worden zonder eerst een instantie van deze klasse te maken (als JSON wordt opgehaald hebben we er immers nog geen). De tweede functie, toJSON, is een functie die de applicatie kan aanroepen op een object om deze om te zetten naar JSON. Deze functies zijn aanwezig bij zowel de Rudiment klasse als de PracticeSession klasse, dus de klassen waarvan er data naar en van de backend moet gestuurd worden. 
Voor de FP frontend applicatie werd alvast een compose methode aangemaakt, deze vergemakkelijkt het samenstellen van (pure) functies die opeenvolgende worden uitgevoerd met het resultaat van de functie ervoor. Dit is een higher order functie aangezien de functie zelf een functie retourneert. De functie neemt een onbepaalde aantal functies als argument, keert deze volgorde om, en retourneert dan een functie die een onbepaald aantal argumenten heeft. Deze geretourneerde functie zal via een reduce functie de lijst van functies toepassen, waarvan de eerste aangeroepen functie de argumenten meekrijgt die werden meegeven en de volgende functies zullen telkens het resultaat van de vorige meekrijgen als argument.
De beide backend applicaties maken gebruik van Node.js, Express, MongoDB en Mongoose om een REST API op te zetten. Analoog aan de frontend werd het project aangemaakt via het \textit{npm init} commando en werden de dependencies geïnstalleerd met behulp van NPM en het \textit{npm install --save *package*} commando. Het project bevat slechts één development dependency nl. Nodemon voor het opzetten van een live dev server die het development proces vergemakkelijkt door middel van live reloading wanneer de code wijzigt. 

\subsection{Frontend}
 \subsubsection{Metronoom}
 Het eerste onderdeel dat werd geïmplementeerd was de metronoom. Er werd eerst een MetronoomController gecreëerd, deze zal de koppeling vormen tussen View en Model. De Controller zal deze instantie van Metronome beheren zonder dat de View eraan kan (hier wordt er dus gebruik gemaakt van het facade pattern). Deze controller krijgt een aantal HTML elementen en maakt daar event listeners op aan zodat de Controller kan reageren op handelingen vanuit de user interface. Voor de implementatie van de user interface moest een label continu geüpdatet worden aan de hand van de huidige waarde van een slider. Verder moest ook een knop geïmplementeerd worden om de metronoom te doen starten en stoppen en moest een select lijst opgevuld worden met de verschillende mogelijke geluiden van een metronoom. Voor de OOP applicatie werd hiervoor de klasse Metronome gebruikt, waarvan de applicatie een instantie aanmaakt. Aan de slider werd een event listener verbonden die het tempo van de het Metronome object instelt en het label update zodat de user interface continu het juiste huidige tempo weergeeft. Duwen op de knop roept een methode op van de Metronome. Eerst kijkt de applicatie naar het \textit{playing} veld van het Metronome object, dit veld geeft aan of de metronoom al dan niet al aan het spelen is. Indien niet dan wordt de play methode aangeroepen en begint de metronoom te spelen door middel van de setInterval methode die tijdens elk interval een functie aanroept (in dit geval het tikken van de metronoom). Als de metronoom niet aan het spelen is dan wordt de stopfunctie aangeroepen, deze verwijdert het lopende interval. Bij het select input veld werd eerst de lijst aangevuld met de beschikbare opties. Een enumeratie (enum) *FOOTER* houdt de verschillende mogelijk geluiden bij. Daar een enum type niet bestaat in puur JavaScript werd er gebruik gemaakt van de Object.freeze methode, deze sluit het meegegeven object af voor wijzigingen. Vervolgens itereert de controller over dit object door middel van een for...in loop, deze zal alle properties van het object doorlopen. Voor elke property maakt de controller dan een gepaste HTML node aan, in dit geval een option node. Daaraan hangt de controller dan tekst en hangt de volledige node dan aan het select input veld. Aan dit veld voegt de controller dan nog een event listener toe die bij het selecteren van een optie het sound veld van het Metronome object zal instellen met de gekozen waarde. 
 Voor de FP applicatie bleek dit een moeilijk onderdeel om te implementeren. FP draait nu eenmaal rond pure functies, maar voor de metronoom is er geen input data en moet er ook niets geretourneerd worden. Dit onderdeel bestaat voornamelijk uit neveneffecten zoals het instellen van een veld van de user interface, het spelen en stoppen van de metronome etc., iets wat niet past bij een functionele aanpak. Analoog aan de OOP aanpak voegt de applicatie een event listener toe aan de slider zodat het label kan ingesteld worden met de juiste tempo waarde. Voor het spelen van de metronoom moet ook nog een regel van FP gebroken worden: immutability. Het spelen van de metronoom maakt weer gebruik van de setInterval functie. Dit interval moet bijgehouden worden zodat het bij het stoppen van de metronoom kan verwijderd worden. Hiervoor maakt de applicatie gebruik van een \textit{let} variabele, die muteerbaar is en dus een regel breekt van het functioneel programmeren. De staat van spelen van de metronoom houdt de applicatie ook niet bij, hiervoor is de applicatie afhankelijk van de tekst in de knop. Als deze op 'Play' staat dan is de metronoom niet aan het spelen, bij 'Stop' speelt deze dan weer wel. Dit maakt de applicatie echter afhankelijk van de View, wat geen best practice is aangezien deze beter losgekoppeld is van de logica. Het aanvullen van het select input veld met de verschillende geluidsopties is dan weer wel iets dan goed werkt binnen de FP applicatie. De applicatie itereert over de waarden van de makeshift enum en roept hierop de map functie aan. Aan de map functie wordt dan een pure functie meegegeven die als input de string waarde van het geluid meekrijgt en als output een HTML element. Zo zal er voor elke waarde een HTML element aangemaakt worden en geeft de map functie dan een nieuwe lijst terug met deze elementen. Vervolgens vult de applicatie het select input veld op via de forEach functie die over de lijst itereert en een functie meekrijgt. Deze keer is dit geen pure functie, maar dit is een uitzondering die moet gemaakt worden om de View te kunnen wijzigen.

 \subsubsection{Lijst van Rudiments}
 Dit onderdeel bestaat uit een lijst van rudiments met een tekstveld waarop de lijst kan gefilterd worden. Hiervoor staat in de HTML een input tekstveld klaar en een leeg HTML lijstelement (ul). Om in de OOP applicatie deze lijst van rudiments te beheren werd er opnieuw een controller gemaakt, RudimentController, die de rudiments zal opvragen van de backend en bijhouden. De controller krijgt het HTML lijstelement mee via de constructor en kan zo hier de aparte elementen voor elk rudiment aanhangen. Dit gebeurt via een showRudiments functie die over de lijst van rudiments zal itereren en per rudiment een HTML element aanmaken. Vervolgens hangt de controller deze elementen aan het lege HTML lijstelement dat hij meekreeg via zijn constructor. Voor de implementatie van de filter werd er een eventlistener toegevoegd aan het input tekstveld. Bij het veranderen van de input (dus wanneer er getypt wordt bv.) zal de applicatie de showRudiments functie opnieuw aanroepen. Deze wordt werd uitgebreid met een filter argument en nog een extra instructie die voor het aanmaken van de elementen eerst nog over de lijst itereert en de naam van het rudiment vergelijk met de tekst van de filter. Als de filtertekst voorkomt in de naam dan zal het rudiment toegevoegd worden aan een filteredRudiments array. De controller itereert dan over deze array zodat de View steeds de juiste rudiments toont op basis van de filtertekst in het input veld. Het ophalen van de rudiments gebeurt via de fetch functie. Die functie verwacht een url en eventuele opties om de request te configureren. Om alle rudiments op te halen is hier enkel een url nodig. De RudimentController haalt deze rudiments op via een get request en zet de verkregen rudiments om van JSON naar objecten van de Rudiment klasse. Deze objecten zal de RudimentController bijhouden zodat er bij het filteren niet telkens opnieuw een netwerk call moet gebeuren.

De implementatie van dit onderdeel verreist het verwerken van een lijst met data, wat een sterkte is van functioneel programmeren. Voor het opvullen van het HTML lijstelement gebruiken we de compose methode, deze zal een reeks functies uitvoeren met als beginnend argument een lijst data die rudiments bevat. Als eerste functie roept geeft de applicatie een getItemNodes functie mee. Deze methode maakt gebruik van currying zodat er eerst een aantal argument kunnen meegeven worden. De functie zal telkens opnieuw een functie teruggeven tot de applicatie de lijst van rudiments meegeeft, waarna de functie het echte werk doet met behulp van de voorgaande argumenten. Als eerste argument krijgt getItemNodes een mapFunctie mee die zal bepalen hoe elk item gemapt zal worden naar een HTML element. Voor deze mapFunctie geeft de applicatie de functie createRudimentListNode mee, deze verwacht als argument een rudiment en maakt hiervoor de nodig HTML elementen aan en geeft deze dan terug. Voorlopig is dit een lijstelement die een tekstnode bevat waarin de details van het rudiment staan (naam en sticking). Als tweede argument voor de compose functie geeft de applicatie de appendToDomElement functie mee. Deze maakt weer gebruik van currying en verwacht als eerste argument een DOM element waaraan het items zal aan toevoegen. Deze items zijn dan ook het tweede argument van deze functie. De compose functie met de argument getItemNodes en appendToDomElement geeft dan opnieuw een functie terug die het beginnende argument verwacht, dit is de lijst met rudiments. Vervolgens zal deze lijst doorgegeven worden aan de getItemNodes functie die zijn mapFunctie argument zal toepassen op deze items en het resultaat retourneren. Dit resultaat, de lijst van HTML elementen, wordt op zijn beurt doorgegeven aan de appendToDomElement zodat de functie deze elementen toevoegt aan zijn DOM element argument. Deze compositie van functies is makkelijk herbruikbaar en zal dan ook hergebruikt worden voor het volgende onderdeel. Vervolgens werd er een event listener toegevoegd aan het input tekstveld. Deze zal opnieuw gebruik maken van de compose functie met als argumenten appendToDomElement en getItemNodes maar ook de functie. Om de data op te halen vanuit de backend maakt de applicatie gebruik van de get hulpfunctie. Deze functie roept de fetch functie aan en vervolgens de json functie van diens respons zodat deze code niets steeds herhaalt moet worden. Om ervoor te zorgen dat er niet steeds nieuwe netwerk calls nodig zijn stopt de applicatie de rudiments wel in een variabele, hoewel dit tegenstrijdig is met het immutability principe aangezien deze variabele eerst vooraf gedefinieerd moet worden en later gemuteerd door de rudiments eraan toe te kennen.

 \subsubsection{Lijst van Practice Sessions}
 Deze functionaliteit omvat een opnieuw een lijst maar deze keer geen lijst waarop gefilterd kan worden, maar een lijst de het mogelijk maakt om items toe te voegen en te verwijderen. Deze items omvatten sessies die het tempo tonen die gebruikt werd tijdens te sessie en de tijdsduur ervan. Deze sessies horen bij een rudiment en de gebruiker kan ze één voor één verwijderen of alle sessies verwijderen voor één rudiment. De practice sessions moeten getoond worden wanneer een rudiment geselecteerd wordt zodat zijn bijhorende practice sessions in de lijst worden weergegeven.

Analoog aan de vorige onderdeel werd voor de OOP applicatie opnieuw een controller gemaakt, de PracticeSessionController. De constructor van deze controller verwacht deze keer geen leeg HTML lijst element maar een gewoon HTML div element. De controller maakt in zijn constructor dan zelf een lijstelement aan hij zal toevoegen aan het div element. Net zoals voorgaand onderdeel bevat de controller een showPracticeSession functie, ditmaal met als argument een lijst van practiceSessions. Deze lijst zal opnieuw doorlopen worden en per practiceSessions maakt de controller een HTML element aan die zal worden toegevoegd aan het HTML lijst element. Als de lijst leeg is dan stelt de controller het div element in met een gepaste tekst, vandaar dat deze implementatie iets anders is dan het vorige onderdeel van de lijst van rudiments. Voor het selecteren van een rudiment werd een eventlistener toegevoegd aan de RudimentController. Door middel van het gebruik van overerving breidt de controller dan de klasse EventTarget uit zodat deze zelf events kan sturen die door zijn listeners kunnen ontvangen worden. Vervolgens werd de showRudiments functie aangepast door aan een lijstelement nog een anchorelement toe te voegen. Dit zorgt ervoor dat er op een rudiment lijstelement kan geklikt worden. Bij een klik zal de RudimentController dan een event uitsturen die het desbetreffende rudiment meegeeft. De applicatie zal dan op dit event reageren door de practice sessions te tonen van het meegegeven rudiment. Bij elke klik op een rudiment geeft de applicatie dan de juiste lijst van practice sessions weer, of een gepaste tekst indien het rudiment nog geen practice sessions zou hebben. Het ophalen van de practice sessions gebeurt via een get request die de id van het geselecteerde rudiment zal meegeven zodat de backend de juiste practice sessions kan teruggeven.  

Om dit onderdeel te implementeren in de FP applicatie werden de functies getItemNodes en appendToDomElement van vorig onderdeel hergebruikt. Het argument dat de applicatie meegeeft aan getItemNodes is ditmaal een functie die een practice session zal omzetten naar een gepast HTML element. Dit omzetten en toevoegen van elementen roept de applicatie in de functie onRudimentClick. Deze gecurryde methode verwacht als eerste argument een HTML element om de lijst van practice session elementen aan toe te voegen en een placeholder om weer te geven indien er het geselecteerde rudiment geen practice sessions zou bevatten. De functie zal bij elke aanroep het meegegeven HTML element leegmaken zodat de applicatie telkens de juiste data kan tonen zonder dat de vorige data nog aanwezig is. Als laatste argument om de functie mee aan te roepen volgt de practice sessions data lijst. Als deze lijst niet leeg is zal de de functie zelf een HTML lijst element creëren en zal de functie vervolgens over de data lijst itereren en de gepaste HTML elementen aanmaken om deze vervolgens toe te voegen aan het gecreëerde HTML lijst element. Dit element wordt dan op diens beurt toegevoegd aan het HTML element die als eerste argument werd meegegeven aan de functie. Indien de data lijst leeg blijkt te zijn of niet werd meegegeven maakt de functie een HTML paragraaf element aan die als de tekst het meegegeven placeholder argument zal bevatten. In dit geval is dit een boodschap die vermeld dat er voor het geselecteerde rudiment nog geen practice sessions zijn. Om de onRudimentClick functie te gebruiken in de applicatie werd de createRudimentListNode functie aangepast. Hiervoor werd er opnieuw currying toegepast zodat deze functie als eerste argument nu een onClick methode verwacht. Verder maakt de createRudimentListNode nu een anchor HTML element aan zodat als er op geklikt wordt de anchor de meegegeven onClick methode aanroept, in dit geval is dit de onRudimentClick methode. Analoog aan de OOP applicatie wordt het anchor element rond de beschrijving van het rudiment gezet zodat erop geklikt kan worden zodat de applicatie de bijhorende practice sessions van het rudiment weergeeft of een gepaste tekst indien het geselecteerde rudiment geen practice sessions bevat. Het ophalen van de practice sessions gebeurt in de onRudimentClick functie. Deze zal het id van het meegegeven rudiment gebruiken om via een get request de juiste practice sessions op te halen uit de backend.

\subsection{Backend}
\subsubsection{OOP}
Alhoewel de OOP backend applicatie geen klassen definieert werkt deze toch volgens het OOP principe. De applicatie past ook het MVC pattern toe door middel van het gebruik van controllers aan wie het ophalen en beheren van data wordt gedelegeerd. Voor het gebruik van de MongoDB databank werden schema's gemaakt die de eigenschappen van een document bepalen, gelijkaardig aan het definieren van een klasse (maar zonder methoden uiteraard, enkel met data). Voor het aanspreken van deze methoden van de controllers definieert de applicatie enkel routes, de /rudiment routes delegeert deze dan aan de rudimentController terwijl het aanspreken van de /practiceSessions routes zullen gedelegeerd worden aan de practiceSessionController. De rudimentController beheert ook deels de practice sessions maar dan die van een specifiek rudiment dat wordt opgevraagd. Het opvragen van zo'n specifiek rudiment gebeurt via de /rudiment/:rudimentId route en diens practice sessions kunnen dan opgevraagd worden door /practiceSessions aan die route toe te voegen. Ophalen van de rudiments en practice sessions gebeurt via get requests, het toevoegen van practice sessions via post requests en het verwijderen van deze gebeurt door delete requests. Deze data die de applicatie meegeeft en meekrijgt via deze requests staat in JSON formaat. De structuur voor het voldoen aan een request is redelijk vast, de backend spreekt voor de aangesproken route een gepaste methode aan op een controller klasse en deze methode roept op diens beurt één of meerdere functies aan op één of meerdere collecties uit de MongoDB databank. Verder maakt de applicatie ook nog gebruik van overerving. Beide controller klasse breiden een algemene Controller klasse uit. Van deze klasse zelf kan geen instantie gemaakt worden, net zoals een abstracte klasse, alleen is dit in principe geen echte abstracte klasse aangezien dit concept niet bestaat in puur JavaScript. Deze algemene klasse bevat al 3 methodes: getAll, getById en add. Dit zijn veel voorkomende methodes waarvan de implementatie steeds dezelfde is. Deze methoden hangen alleen af van een Mongoose Model zodat de juiste collectie uit de MongoDB databank kan gebruikt worden. Het model geeft de gespecialiseerde controller klasse mee in zijn constructor door dit mee te geven aan de super functie. Deze super functie roept de constructor van de superklasse aan en stelt zo het model in bij de superklasse. Zo geeft de RudimentController het Rudiment model mee in zijn constructor. Wanneer de applicatie de getAll functie aanroept op de RudimentController dan zal deze functie gebruik maken van het Rudiment model. Verder hebben beide controllers ook nog functies die eigen zijn aan die klasse en dus niet hergebruikt kunnen worden.

\subsubsection{FP}
Waar de routes bij OOP applicatie de afhandeling voor een request overdragen aan een Controller, gebeurt dit bij de FP backend via het samenstellen van functies. Zo definieert de applicatie een aantal basis functies die dan hergebruikt kunnen worden in specifiekere functies. Deze gecurry'de basisfuncties zijn voor het ophalen, wijzigen, toevoegen en verwijderen van documenten in de MongoDB databank en verwachten telkens als eerste argument het Mongoose Model zodat . Deze functies zijn dan nog eens opgedeeld in het beheren van alle documenten in een collectie, één document dat via het id wordt opgehaald of één of meerdere documenten die worden opgehaald via een documentquery. Met deze basisfuncties definieert de backend dan specifieke functies om effectief rudiments of practice sessions te beheren. Het beheren van deze documenten in de databanken is uiteraard een neveneffect en dus geen gewenste handeling binnen het functioneel programmeren. Daarom stopt de applicatie deze handelingen in een Promise object. Dit zorgt ervoor dat het neveneffect zich niet meteen voordoet maar slechts wanneer via await de desbetreffende functie wordt aangeroepen. Op deze manier is er wel nog een soort van controle over het het uitvoeren van dit neveneffect. Verder definieert de applicatie ook nog enkel hulpfuncties om wat boilerplate code te verminderen, zoals voor het afhandelen van een binnenkomende request (er wordt ofwel JSON ofwel een foutmelding teruggestuurd) en voor het afhandelen van een respons vanuit de databank (een Promise moet geweigerd worden bij een foutmelding en opgelost worden bij het terugkrijgen van een resultaat).